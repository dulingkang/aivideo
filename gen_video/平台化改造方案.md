# AI视频生成平台化改造方案

## 一、架构设计

### 1.1 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                    API Gateway Layer                     │
│  (FastAPI/Flask + Authentication + Rate Limiting)        │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│                  Task Queue Layer                        │
│  (Celery/Redis/RabbitMQ - 异步任务处理)                  │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│              Core Generation Services                    │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │ Image Gen    │  │ Video Gen    │  │ Audio Gen    │  │
│  │ Service      │  │ Service      │  │ Service      │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│              Resource Management Layer                   │
│  (GPU Pool, Model Cache, Storage Management)            │
└─────────────────────────────────────────────────────────┘
```

### 1.2 核心组件

1. **API服务层**：提供RESTful API接口
2. **任务队列**：异步任务处理，支持优先级和重试
3. **配置管理**：动态配置加载，支持多租户
4. **资源管理**：GPU池管理，模型缓存，存储管理
5. **监控系统**：任务状态、性能指标、错误追踪
6. **用户管理**：认证、授权、配额管理

## 二、API接口设计

### 2.1 图像生成API

```python
POST /api/v1/images/generate
{
    "prompt": "string",
    "negative_prompt": "string",
    "width": 1536,
    "height": 864,
    "num_inference_steps": 40,
    "guidance_scale": 7.5,
    "seed": null,
    "character_id": "hanli",
    "scene_config": {
        "camera": "medium shot",
        "lighting": "soft",
        "mood": "calm"
    },
    "style": "xianxia",
    "output_format": "png"
}

Response:
{
    "task_id": "uuid",
    "status": "queued",
    "estimated_time": 30
}
```

### 2.2 视频生成API

```python
POST /api/v1/videos/generate
{
    "scenes": [
        {
            "id": 0,
            "prompt": "string",
            "duration": 5.0,
            "image_path": "optional_pre_generated_image"
        }
    ],
    "video_config": {
        "fps": 24,
        "resolution": "1280x768",
        "upscale": true,
        "audio": true
    },
    "output_format": "mp4"
}

Response:
{
    "task_id": "uuid",
    "status": "queued",
    "estimated_time": 300
}
```

### 2.3 任务查询API

```python
GET /api/v1/tasks/{task_id}

Response:
{
    "task_id": "uuid",
    "status": "processing|completed|failed",
    "progress": 45,
    "result": {
        "output_path": "url",
        "thumbnail": "url"
    },
    "error": null
}
```

## 三、配置管理系统

### 3.1 多层级配置

```yaml
# 系统级配置 (system_config.yaml)
system:
  gpu_pool:
    enabled: true
    max_concurrent: 4
  model_cache:
    enabled: true
    max_size_gb: 100
  storage:
    type: "local|s3|oss"
    base_path: "/data/outputs"

# 用户级配置 (user_config.yaml)
users:
  default:
    quotas:
      images_per_day: 100
      videos_per_day: 10
      max_resolution: "1920x1080"
    limits:
      max_duration: 60  # seconds
      max_frames: 1440

# 项目级配置 (project_config.yaml)
projects:
  xianxia:
    character_profiles: "character_profiles.yaml"
    scene_profiles: "scene_profiles.yaml"
    style: "xianxia"
    default_engine: "instantid"
```

### 3.2 动态配置加载

```python
class ConfigManager:
    def __init__(self):
        self.system_config = self.load_system_config()
        self.user_configs = {}
        self.project_configs = {}
    
    def get_config(self, user_id: str, project_id: str = None):
        """获取合并后的配置"""
        config = self.system_config.copy()
        if user_id in self.user_configs:
            config = self.merge_config(config, self.user_configs[user_id])
        if project_id and project_id in self.project_configs:
            config = self.merge_config(config, self.project_configs[project_id])
        return config
```

## 四、任务队列系统

### 4.1 Celery任务定义

```python
from celery import Celery
from celery.result import AsyncResult

app = Celery('video_gen', broker='redis://localhost:6379/0')

@app.task(bind=True, max_retries=3)
def generate_image_task(self, config: dict, user_id: str):
    """图像生成任务"""
    try:
        generator = ImageGenerator(config)
        result = generator.generate_image(
            prompt=config['prompt'],
            output_path=config['output_path']
        )
        return {
            'status': 'completed',
            'result': result
        }
    except Exception as exc:
        # 重试逻辑
        raise self.retry(exc=exc, countdown=60)

@app.task(bind=True, max_retries=2)
def generate_video_task(self, config: dict, user_id: str):
    """视频生成任务"""
    # 视频生成逻辑
    pass
```

### 4.2 任务优先级和资源分配

```python
# 高优先级任务（VIP用户）
@app.task(priority=9)
def generate_image_vip(config, user_id):
    pass

# 普通任务
@app.task(priority=5)
def generate_image_normal(config, user_id):
    pass

# 低优先级任务（免费用户）
@app.task(priority=1)
def generate_image_free(config, user_id):
    pass
```

## 五、资源管理

### 5.1 GPU池管理

```python
class GPUPool:
    def __init__(self, gpu_ids: List[int]):
        self.gpus = {gpu_id: {'busy': False, 'task': None} 
                     for gpu_id in gpu_ids}
        self.lock = threading.Lock()
    
    def acquire(self, task_id: str, timeout: int = 300):
        """获取GPU资源"""
        with self.lock:
            for gpu_id, status in self.gpus.items():
                if not status['busy']:
                    status['busy'] = True
                    status['task'] = task_id
                    return gpu_id
        raise ResourceUnavailable("No GPU available")
    
    def release(self, gpu_id: int):
        """释放GPU资源"""
        with self.lock:
            self.gpus[gpu_id]['busy'] = False
            self.gpus[gpu_id]['task'] = None
```

### 5.2 模型缓存管理

```python
class ModelCache:
    def __init__(self, max_size_gb: int = 100):
        self.cache = {}
        self.max_size = max_size_gb * 1024 * 1024 * 1024
        self.current_size = 0
    
    def load_model(self, model_path: str, model_type: str):
        """加载模型（带缓存）"""
        cache_key = f"{model_type}:{model_path}"
        if cache_key in self.cache:
            return self.cache[cache_key]
        
        model = self._load_from_disk(model_path, model_type)
        self._add_to_cache(cache_key, model)
        return model
    
    def _add_to_cache(self, key: str, model):
        """添加到缓存（LRU策略）"""
        if self.current_size >= self.max_size:
            self._evict_lru()
        self.cache[key] = model
        self.current_size += self._get_model_size(model)
```

## 六、用户管理和配额

### 6.1 用户配额管理

```python
class QuotaManager:
    def __init__(self, db):
        self.db = db
    
    def check_quota(self, user_id: str, resource_type: str):
        """检查用户配额"""
        user = self.db.get_user(user_id)
        quota = user.quotas.get(resource_type)
        usage = self.get_usage(user_id, resource_type)
        
        if usage >= quota.limit:
            raise QuotaExceeded(f"{resource_type} quota exceeded")
        return True
    
    def consume_quota(self, user_id: str, resource_type: str, amount: int = 1):
        """消耗配额"""
        self.db.increment_usage(user_id, resource_type, amount)
```

### 6.2 认证和授权

```python
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

async def get_current_user(token: str = Depends(oauth2_scheme)):
    """验证用户token"""
    user = verify_token(token)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials"
        )
    return user

@app.post("/api/v1/images/generate")
async def generate_image(
    request: ImageRequest,
    current_user: User = Depends(get_current_user)
):
    """需要认证的图像生成接口"""
    quota_manager.check_quota(current_user.id, "images")
    # 生成逻辑
```

## 七、监控和日志

### 7.1 任务监控

```python
class TaskMonitor:
    def __init__(self):
        self.metrics = {
            'total_tasks': 0,
            'completed_tasks': 0,
            'failed_tasks': 0,
            'avg_processing_time': 0,
            'gpu_utilization': {}
        }
    
    def record_task_start(self, task_id: str, task_type: str):
        """记录任务开始"""
        self.metrics['total_tasks'] += 1
        # 记录到数据库
    
    def record_task_complete(self, task_id: str, duration: float):
        """记录任务完成"""
        self.metrics['completed_tasks'] += 1
        # 更新平均处理时间
    
    def get_metrics(self):
        """获取监控指标"""
        return self.metrics
```

### 7.2 日志系统

```python
import logging
from logging.handlers import RotatingFileHandler

def setup_logging():
    """设置日志系统"""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            RotatingFileHandler('logs/app.log', maxBytes=10*1024*1024, backupCount=5),
            logging.StreamHandler()
        ]
    )
```

## 八、数据库设计

### 8.1 核心表结构

```sql
-- 用户表
CREATE TABLE users (
    id VARCHAR(36) PRIMARY KEY,
    email VARCHAR(255) UNIQUE,
    api_key VARCHAR(64) UNIQUE,
    quota_config JSON,
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);

-- 任务表
CREATE TABLE tasks (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36),
    task_type VARCHAR(50),
    status VARCHAR(20),
    config JSON,
    result JSON,
    error_message TEXT,
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    completed_at TIMESTAMP
);

-- 配额使用记录
CREATE TABLE quota_usage (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36),
    resource_type VARCHAR(50),
    amount INT,
    date DATE,
    INDEX idx_user_date (user_id, date)
);
```

## 九、部署方案

### 9.1 Docker容器化

```dockerfile
# Dockerfile
FROM nvidia/cuda:11.8.0-cudnn8-runtime-ubuntu22.04

WORKDIR /app

# 安装依赖
COPY requirements.txt .
RUN pip install -r requirements.txt

# 复制代码
COPY . .

# 启动服务
CMD ["uvicorn", "api.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### 9.2 Docker Compose

```yaml
version: '3.8'

services:
  api:
    build: .
    ports:
      - "8000:8000"
    environment:
      - REDIS_URL=redis://redis:6379/0
      - DATABASE_URL=postgresql://user:pass@db:5432/videogen
    depends_on:
      - redis
      - db
  
  worker:
    build: .
    command: celery -A tasks worker --loglevel=info
    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              count: all
              capabilities: [gpu]
    depends_on:
      - redis
      - db
  
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
  
  db:
    image: postgres:15
    environment:
      POSTGRES_DB: videogen
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
```

## 十、实施步骤

### 阶段1：基础API框架（1-2周）
1. 搭建FastAPI框架
2. 实现基础认证
3. 实现图像生成API
4. 实现任务查询API

### 阶段2：任务队列系统（1周）
1. 集成Celery
2. 实现异步任务处理
3. 实现任务状态追踪

### 阶段3：配置管理（1周）
1. 实现多层级配置系统
2. 实现动态配置加载
3. 实现配置验证

### 阶段4：资源管理（1-2周）
1. 实现GPU池管理
2. 实现模型缓存
3. 实现存储管理

### 阶段5：用户管理（1周）
1. 实现用户认证
2. 实现配额管理
3. 实现使用统计

### 阶段6：监控和优化（1周）
1. 实现监控系统
2. 实现日志系统
3. 性能优化

## 十一、最佳实践

### 11.1 错误处理

```python
class VideoGenException(Exception):
    """基础异常类"""
    pass

class QuotaExceeded(VideoGenException):
    """配额超限"""
    pass

class ResourceUnavailable(VideoGenException):
    """资源不可用"""
    pass

@app.exception_handler(VideoGenException)
async def video_gen_exception_handler(request, exc):
    return JSONResponse(
        status_code=400,
        content={"error": str(exc), "type": exc.__class__.__name__}
    )
```

### 11.2 参数验证

```python
from pydantic import BaseModel, Field, validator

class ImageRequest(BaseModel):
    prompt: str = Field(..., min_length=1, max_length=500)
    width: int = Field(1536, ge=512, le=2048)
    height: int = Field(864, ge=512, le=2048)
    num_inference_steps: int = Field(40, ge=10, le=100)
    
    @validator('width', 'height')
    def validate_resolution(cls, v):
        if v % 8 != 0:
            raise ValueError('Resolution must be multiple of 8')
        return v
```

### 11.3 缓存策略

```python
from functools import lru_cache
import hashlib

def get_cache_key(prompt: str, config: dict) -> str:
    """生成缓存键"""
    content = f"{prompt}:{json.dumps(config, sort_keys=True)}"
    return hashlib.md5(content.encode()).hexdigest()

@lru_cache(maxsize=100)
def get_cached_image(cache_key: str):
    """获取缓存的图像"""
    # 从缓存加载
    pass
```

## 十二、API文档

使用OpenAPI/Swagger自动生成API文档：

```python
from fastapi import FastAPI
from fastapi.openapi.utils import get_openapi

app = FastAPI(
    title="AI Video Generation Platform",
    description="通用AI视频生成平台API",
    version="1.0.0"
)

@app.get("/openapi.json")
async def get_openapi():
    return get_openapi(
        title=app.title,
        version=app.version,
        routes=app.routes
    )
```

## 十三、安全考虑

1. **API密钥管理**：使用环境变量或密钥管理服务
2. **输入验证**：严格验证所有用户输入
3. **速率限制**：防止API滥用
4. **资源隔离**：不同用户任务隔离执行
5. **数据加密**：敏感数据加密存储
6. **访问控制**：基于角色的访问控制（RBAC）

## 十四、扩展性设计

1. **水平扩展**：支持多worker节点
2. **插件系统**：支持自定义生成器插件
3. **多模型支持**：支持切换不同的AI模型
4. **多存储后端**：支持S3、OSS等云存储
5. **多语言支持**：国际化API响应

